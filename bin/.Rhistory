test<-read.table("test_counts_50000_filt_1000.tsv", header=TRUE, sep = "\t")
matrix<-read.table("test_counts_50000_filt_1000.tsv", header=TRUE, sep = "\t")
# get a matrix with barcode names in the first column and the number of reads in the second
longMatrix<-data.frame(Barcodes=colnames(matrix[,-1]), nbReads=colSums(matrix[,-1]))
matrix
colnames(matrix[,-1])
matrix
matrix[,1]
matrix[,2]
matrix[,-1]
colnames(matrix[,-1])
names(matrix[,-1])
colnames(matrix[,1])
names(matrix[,1])
colnames(matrix)
colnames(matrix)[,-1]
colnames(matrix)[-1]
colSums(matrix[,-1])
colSums(matrix)[-1]
colnames(matrix)[-1]
sum(matrix[,-1])
# get a matrix with barcode names in the first column and the number of reads in the second
if(colSums(matrix)==2){
longMatrix<-data.frame(Barcodes=colnames(matrix)[-1], nbReads=sum(matrix[,-1]))
}else{
longMatrix<-data.frame(Barcodes=colnames(matrix)[-1], nbReads=colSums(matrix[,-1]))
}
data.frame(Barcodes=colnames(matrix)[-1], nbReads=sum(matrix[,-1]))
# get a matrix with barcode names in the first column and the number of reads in the second
if(ncol(matrix)==2){
longMatrix<-data.frame(Barcodes=colnames(matrix)[-1], nbReads=sum(matrix[,-1]))
}else{
longMatrix<-data.frame(Barcodes=colnames(matrix)[-1], nbReads=colSums(matrix[,-1]))
}
# y = sum des reads par bin, x= #readsTot/cell (on ne sait cb de cellules ont entre x1 et x2 reads)
weighted.hist(log10(longMatrix$nbReads), w=longMatrix$nbReads, ylab ="sum #reads/bin", xlab="log10(#reads/cell)")
(
(
library(plotrix)
library(reshape2)
library(plotrix)
library(reshape2)
setwd("~/Documents/Curie/SC_platform/Analysis/scChiPseq/Gitlab/weighted_hist/")
# y = sum des reads par bin, x= #readsTot/cell (on ne sait cb de cellules ont entre x1 et x2 reads)
weighted.hist(log10(longMatrix$nbReads), w=longMatrix$nbReads, ylab ="sum #reads/bin", xlab="log10(#reads/cell)")
# 1st - calculate the center (== mean) of each bin because only a curve can be drawn with mqc
# To do so, the center of each bin is calculated
# Get first list of mean bins
breaks<-list(p[["breaks"]])
matrix<-read.table("test_counts_50000_filt_1000.tsv", header=TRUE, sep = "\t")
# get a matrix with barcode names in the first column and the number of reads in the second
if(ncol(matrix)==2){
# If only one cell (test data)
longMatrix<-data.frame(Barcodes=colnames(matrix)[-1], nbReads=sum(matrix[,-1]))
}else{
longMatrix<-data.frame(Barcodes=colnames(matrix)[-1], nbReads=colSums(matrix[,-1]))
}
# y = sum des reads par bin, x= #readsTot/cell (on ne sait cb de cellules ont entre x1 et x2 reads)
weighted.hist(log10(longMatrix$nbReads), w=longMatrix$nbReads, ylab ="sum #reads/bin", xlab="log10(#reads/cell)")
breaks<-list(p[["breaks"]])
# y = sum des reads par bin, x= #readsTot/cell (on ne sait cb de cellules ont entre x1 et x2 reads)
p<-weighted.hist(log10(longMatrix$nbReads), w=longMatrix$nbReads, ylab ="sum #reads/bin", xlab="log10(#reads/cell)")
breaks<-list(p[["breaks"]])
splitNum<-length(breaks[[1]])/2
splitedBreaks1 <- lapply(breaks, function(x) split(unlist(x), cut(seq_along(unlist(x)), splitNum, labels = F)))
weightedHist_DF<-data.frame(y=0,x=0)
weightedHist_DF
weightedHist_DF<-data.frame()
weightedHist_DF
pdf(paste0(as.character(prefix), 'distribution.pdf'))
dev.off()
pdf(paste0(as.character("prefix"), 'distribution.pdf'))
dev.off()
# get a matrix with barcode names in the first column and the number of reads in the second
# Only if more than one cell
if(ncol(matrix)>2){
longMatrix<-data.frame(Barcodes=colnames(matrix)[-1], nbReads=colSums(matrix[,-1]))
# Histogram and pdf export
pdf(paste0(as.character(prefix), 'distribution.pdf'))
# y = sum des reads par bin, x= #readsTot/cell (on ne sait cb de cellules ont entre x1 et x2 reads)
p<-weighted.hist(log10(longMatrix$nbReads), w=longMatrix$nbReads, ylab ="sum #reads/bin", xlab="log10(#reads/cell)")
# somme des reads par bin <=> somme des reads de toutes les cellules qui ont entre x1 et x2
# Pour les pics les plus Ã  gauche: pic haut = bcp de cellules qui ont peu de reads
# ==> Le weighted hist permet de montrer la proportion de cellules ayant un faible nombre de reads
dev.off()
# Export table to create the plot with multiqc
# 1st - calculate the center (== mean) of each bin because only a curve can be drawn with mqc
# To do so, the center of each bin is calculated
# Get first list of mean bins
breaks<-list(p[["breaks"]])
splitNum<-length(breaks[[1]])/2
splitedBreaks1 <- lapply(breaks, function(x) split(unlist(x), cut(seq_along(unlist(x)), splitNum, labels = F)))
splitedBreaks1<-unlist(splitedBreaks1, recursive = F)
x1<-lapply(splitedBreaks1, mean)
# Do the same but begining=2nd value to have means of missing bins
breaks<-list(p[["breaks"]][-c(1,length(breaks[[1]]))])
spitNum<-length(breaks[[1]])/2
splitedBreaks2 <- lapply(breaks, function(x) split(unlist(x), cut(seq_along(unlist(x)), spitNum, labels = F)))
splitedBreaks2<-unlist(splitedBreaks2, recursive = F)
x2<-lapply(splitedBreaks2, mean)
# Merge both x and sort result to obtain all the point of the x abscisse
xUnsorted<-unlist(append(x1,x2))
x<-sort(xUnsorted)
# Get y values == counts
y<-p["counts"]
weightedHist_DF<-data.frame(y=y,x=x)
write.table(weightedHist_DF, paste0(as.character(prefix), "_distDF.mqc"),
sep=',', row.names=FALSE, col.names=FALSE)
}else{ # If only one cell, create empty files
pdf(paste0(as.character("prefix"), 'distribution.pdf'))
dev.off()
weightedHist_DF<-data.frame()
write.table(weightedHist_DF, paste0(as.character(prefix), "_distDF.mqc"),
sep=',', row.names=FALSE, col.names=FALSE)
}
# y = sum des reads par bin, x= #readsTot/cell (on ne sait cb de cellules ont entre x1 et x2 reads)
p<-weighted.hist(log10(longMatrix$nbReads), w=longMatrix$nbReads, ylab ="sum #reads/bin", xlab="log10(#reads/cell)")
p
# get a matrix with barcode names in the first column and the number of reads in the second
if(ncol(matrix)==2){
# If only one cell (test data)
longMatrix<-data.frame(Barcodes=colnames(matrix)[-1], nbReads=sum(matrix[,-1]))
}else{
longMatrix<-data.frame(Barcodes=colnames(matrix)[-1], nbReads=colSums(matrix[,-1]))
}
# y = sum des reads par bin, x= #readsTot/cell (on ne sait cb de cellules ont entre x1 et x2 reads)
p<-weighted.hist(log10(longMatrix$nbReads), w=longMatrix$nbReads, ylab ="sum #reads/bin", xlab="log10(#reads/cell)")
p
longMatrix$nbReads
weighted.hist(log10(longMatrix$nbReads), w=longMatrix$nbReads, ylab ="sum #reads/bin", xlab="log10(#reads/cell)")
breaks<-list(p[["breaks"]])
